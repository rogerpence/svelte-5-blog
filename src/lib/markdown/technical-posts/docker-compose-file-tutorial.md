---
title: Docker compose file tutorial
description: Docker compose file tutorial
date_created: '2025-05-18T00:00:00.000Z'
date_updated: '2025-09-30T00:00:00.000Z'
date_published: null
pinned: false
tags:
  - containers
---
Okay, let's create a small tutorial on Docker Compose files.

**What is Docker Compose?**

Docker Compose is a tool for defining and running multi-container Docker applications. Instead of starting each container manually with `docker run` and setting up networks and volumes via the command line, you define your entire application stack (services, networks, volumes) in a single YAML file (usually `docker-compose.yml` or `compose.yml`). This makes managing complex applications much easier.

**Prerequisites:**

-   Docker Engine installed.
-   Docker Compose installed (often included with Docker Desktop).

**The `docker-compose.yml` / `compose.yml` File**

This file uses YAML syntax, which relies heavily on **indentation** (usually 2 spaces) to define structure. The default filename is `docker-compose.yml`, but the newer standard `compose.yml` is also recognized.

**Primary Sections of a Compose File:**

Here are the most common top-level sections you'll encounter:

1.  **`services` (Required):**

    -   This is the heart of the Compose file.
    -   It defines the individual containers that make up your application.
    -   Each key under `services` is a custom name you give to a service (e.g., `web`, `db`, `api`).
    -   Each service definition contains configuration for _how_ to run its container. Common sub-keys include:
        -   `image: <image_name>:<tag>`: Specifies the Docker image to use (e.g., `nginx:latest`, `postgres:15`).
        -   `build: <path_to_build_context>`: Specifies a path to a directory containing a Dockerfile. Compose will build the image before starting the service. You can use `build: .` for the current directory.
        -   `ports: ["<HOST_PORT>:<CONTAINER_PORT>"]`: Maps ports from your host machine to the container (e.g., `"8080:80"` maps host port 8080 to container port 80).
        -   `environment: ["VAR_NAME=value"]` or `environment: {VAR_NAME: value}`: Sets environment variables inside the container.
        -   `volumes: ["<HOST_PATH_OR_NAMED_VOLUME>:<CONTAINER_PATH>"]`: Mounts directories or named volumes into the container for persistent data or code sharing (e.g., `"/path/on/host:/app/data"` or `"db_data:/var/lib/postgresql/data"`).
        -   `networks: [<network_name>]`: Connects the service to specified networks.
        -   `depends_on: [<service_name>]`: Defines startup dependencies. The service will start only after the listed services have started. _Note: This only waits for the container to start, not necessarily for the application inside it to be ready._

2.  **`networks` (Optional):**

    -   Allows you to define custom networks for your services to communicate over.
    -   If omitted, Compose creates a default bridge network for your application.
    -   Defining custom networks gives you more control over isolation and connectivity.
    -   Example: `networks: { app_net: { driver: bridge } }` defines a network named `app_net`.

3.  **`volumes` (Optional):**
    -   Allows you to define named volumes. Named volumes are managed by Docker and are the preferred way to persist data generated by containers.
    -   You define the volume here (e.g., `volumes: { db_data: {} }`) and then reference it within a service's `volumes` section (e.g., `volumes: ["db_data:/var/lib/postgresql/data"]`).

_(Note: The `version` key was required in older Compose file formats but is generally optional now with the modern Compose Specification.)_

**Simple Example: A Web Server and a Redis Cache**

Let's create a simple stack with an Nginx web server and a Redis database.

1.  Create a directory for your project, e.g., `my_compose_app`.
2.  Inside that directory, create a file named `docker-compose.yml` (or `compose.yml`).
3.  Paste the following content into the file:

```yaml
services:
    # Service 1: The web server
    web:
        image: nginx:alpine # Use the official lightweight Nginx image
        ports:
            - "8080:80" # Map host port 8080 to container port 80
        networks:
            - app-network # Connect to our custom network
        depends_on:
            - cache # Wait for the cache service to start first

    # Service 2: The Redis cache
    cache:
        image: redis:alpine # Use the official lightweight Redis image
        networks:
            - app-network # Connect to our custom network
        volumes:
            - cache-data:/data # Mount the named volume 'cache-data' to /data inside the container

# Define custom network(s)
networks:
    app-network:
        driver: bridge # Use the standard bridge network driver

# Define named volume(s) for persistent data
volumes:
    cache-data: {} # Define the named volume 'cache-data'
```

**Explanation:**

-   We define two `services`: `web` and `cache`.
-   `web` uses the `nginx:alpine` image and exposes port 8080 on the host, mapping it to port 80 inside the container.
-   `cache` uses the `redis:alpine` image.
-   Both services are connected to a custom network `app-network`, allowing them to communicate using their service names (e.g., the `web` service could connect to Redis using the hostname `cache`).
-   The `cache` service uses a named volume `cache-data` to persist its data in `/data` inside the container. This volume is defined at the bottom level.
-   `web` `depends_on` `cache`, so Compose will attempt to start `cache` before starting `web`.

**Running Your Compose Application:**

1.  Open your terminal and navigate to the directory containing your `docker-compose.yml` file (`my_compose_app`).
2.  Run the command:
    ```bash
    docker compose up
    ```
    -   This command builds images if necessary (using `build:`), creates networks/volumes if they don't exist, and starts all the services defined in the file. You'll see logs from all containers in your terminal.
    -   Add the `-d` flag (`docker compose up -d`) to run the containers in detached mode (in the background).
3.  To see the running services:
    ```bash
    docker compose ps
    ```
4.  To view logs (especially if running in detached mode):
    ```bash
    docker compose logs
    # or follow logs in real-time
    docker compose logs -f
    # or view logs for a specific service
    docker compose logs web
    ```
5.  To stop and remove the containers, networks, and (optionally) volumes defined in the compose file:
    ```bash
    docker compose down
    # Add -v to remove named volumes as well
    docker compose down -v
    ```

That's a basic introduction! Docker Compose offers many more options for configuration, scaling, health checks, and more, but understanding `services`, `networks`, and `volumes` is the foundation.